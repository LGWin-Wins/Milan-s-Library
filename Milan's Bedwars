local ScreenGui = Instance.new("ScreenGui")
local CombatFrame = Instance.new("Frame")
local Combat = Instance.new("TextLabel")
local UICorner = Instance.new("UICorner")
local UICorner_2 = Instance.new("UICorner")
local Close = Instance.new("TextButton")
local KillAura = Instance.new("TextButton")
local UICorner_3 = Instance.new("UICorner")
local Speed = Instance.new("TextButton")
local UICorner_4 = Instance.new("UICorner")
local Fly = Instance.new("TextButton")
local UICorner_5 = Instance.new("UICorner")
local RenderFrame = Instance.new("Frame")
local TEXTRENDER = Instance.new("TextLabel")
local UICorner_6 = Instance.new("UICorner")
local UICorner_7 = Instance.new("UICorner")
local LINES = Instance.new("TextButton")
local UICorner_8 = Instance.new("UICorner")
local ESPBUTTON = Instance.new("TextButton")
local UICorner_9 = Instance.new("UICorner")
local Close_2 = Instance.new("TextButton")
local WorldFrame = Instance.new("Frame")
local TextWorld = Instance.new("TextLabel")
local UICorner_10 = Instance.new("UICorner")
local UICorner_11 = Instance.new("UICorner")
local infjump = Instance.new("TextButton")
local UICorner_12 = Instance.new("UICorner")
local Close_3 = Instance.new("TextButton")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.ResetOnSpawn = false

CombatFrame.Name = "CombatFrame"
CombatFrame.Parent = ScreenGui
CombatFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
CombatFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
CombatFrame.BorderSizePixel = 0
CombatFrame.Position = UDim2.new(0.165991887, 0, 0.219999969, 0)
CombatFrame.Size = UDim2.new(0.147421926, 0, 0.405867964, 0)

Combat.Name = "Combat"
Combat.Parent = CombatFrame
Combat.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Combat.BorderColor3 = Color3.fromRGB(255, 255, 255)
Combat.BorderSizePixel = 0
Combat.Size = UDim2.new(1, 0, 0.150602415, 0)
Combat.Font = Enum.Font.SourceSansBold
Combat.Text = "Combat"
Combat.TextColor3 = Color3.fromRGB(85, 255, 255)
Combat.TextScaled = true
Combat.TextSize = 14.000
Combat.TextStrokeColor3 = Color3.fromRGB(85, 255, 255)
Combat.TextWrapped = true

UICorner.Parent = Combat

UICorner_2.Parent = CombatFrame

Close.Name = "Close"
Close.Parent = CombatFrame
Close.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Close.BorderColor3 = Color3.fromRGB(0, 0, 0)
Close.BorderSizePixel = 0
Close.Position = UDim2.new(0.886699677, 0, 0, 0)
Close.Size = UDim2.new(0.108374387, 0, 0.0692771077, 0)
Close.Font = Enum.Font.SourceSansBold
Close.Text = "X"
Close.TextColor3 = Color3.fromRGB(0, 0, 0)
Close.TextScaled = true
Close.TextSize = 14.000
Close.TextWrapped = true

KillAura.Name = "KillAura"
KillAura.Parent = CombatFrame
KillAura.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
KillAura.BorderColor3 = Color3.fromRGB(0, 0, 0)
KillAura.BorderSizePixel = 0
KillAura.Position = UDim2.new(1.50332895e-07, 0, 0.150602415, 0)
KillAura.Size = UDim2.new(0.857142866, 0, 0.150602415, 0)
KillAura.Font = Enum.Font.SourceSansBold
KillAura.Text = "KillAura"
KillAura.TextColor3 = Color3.fromRGB(255, 255, 127)
KillAura.TextScaled = true
KillAura.TextSize = 14.000
KillAura.TextWrapped = true

UICorner_3.Parent = KillAura

Speed.Name = "Speed"
Speed.Parent = CombatFrame
Speed.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Speed.BorderColor3 = Color3.fromRGB(0, 0, 0)
Speed.BorderSizePixel = 0
Speed.Position = UDim2.new(-1.68711011e-07, 0, 0.30120483, 0)
Speed.Size = UDim2.new(0.856889963, 0, 0.150602415, 0)
Speed.Font = Enum.Font.SourceSansBold
Speed.Text = "SPEED"
Speed.TextColor3 = Color3.fromRGB(255, 255, 127)
Speed.TextScaled = true
Speed.TextSize = 14.000
Speed.TextWrapped = true

UICorner_4.Parent = Speed

Fly.Name = "Fly"
Fly.Parent = CombatFrame
Fly.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Fly.BorderColor3 = Color3.fromRGB(0, 0, 0)
Fly.BorderSizePixel = 0
Fly.Position = UDim2.new(2.53066503e-07, 0, 0.451807231, 0)
Fly.Size = UDim2.new(0.857142866, 0, 0.150602415, 0)
Fly.Font = Enum.Font.SourceSansBold
Fly.Text = "FLY"
Fly.TextColor3 = Color3.fromRGB(255, 255, 127)
Fly.TextScaled = true
Fly.TextSize = 14.000
Fly.TextWrapped = true

UICorner_5.Parent = Fly

RenderFrame.Name = "RenderFrame"
RenderFrame.Parent = ScreenGui
RenderFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
RenderFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
RenderFrame.BorderSizePixel = 0
RenderFrame.Position = UDim2.new(0.425948441, 0, 0.219999969, 0)
RenderFrame.Size = UDim2.new(0.147421926, 0, 0.405867964, 0)

TEXTRENDER.Name = "TEXT RENDER"
TEXTRENDER.Parent = RenderFrame
TEXTRENDER.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
TEXTRENDER.BorderColor3 = Color3.fromRGB(255, 255, 255)
TEXTRENDER.BorderSizePixel = 0
TEXTRENDER.Size = UDim2.new(1, 0, 0.150602415, 0)
TEXTRENDER.Font = Enum.Font.SourceSansBold
TEXTRENDER.Text = "Render"
TEXTRENDER.TextColor3 = Color3.fromRGB(85, 255, 255)
TEXTRENDER.TextScaled = true
TEXTRENDER.TextSize = 14.000
TEXTRENDER.TextStrokeColor3 = Color3.fromRGB(85, 255, 255)
TEXTRENDER.TextWrapped = true

UICorner_6.Parent = TEXTRENDER

UICorner_7.Parent = RenderFrame

LINES.Name = "LINES"
LINES.Parent = RenderFrame
LINES.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
LINES.BorderColor3 = Color3.fromRGB(0, 0, 0)
LINES.BorderSizePixel = 0
LINES.Position = UDim2.new(0, 0, 0.150602415, 0)
LINES.Size = UDim2.new(0.862068951, 0, 0.150602415, 0)
LINES.Font = Enum.Font.SourceSansBold
LINES.Text = "Lines"
LINES.TextColor3 = Color3.fromRGB(255, 255, 127)
LINES.TextScaled = true
LINES.TextSize = 14.000
LINES.TextStrokeColor3 = Color3.fromRGB(255, 255, 127)
LINES.TextWrapped = true

UICorner_8.Parent = LINES

ESPBUTTON.Name = "ESP BUTTON"
ESPBUTTON.Parent = RenderFrame
ESPBUTTON.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
ESPBUTTON.BorderColor3 = Color3.fromRGB(0, 0, 0)
ESPBUTTON.BorderSizePixel = 0
ESPBUTTON.Position = UDim2.new(0, 0, 0.30120483, 0)
ESPBUTTON.Size = UDim2.new(0.862068951, 0, 0.150602415, 0)
ESPBUTTON.Font = Enum.Font.SourceSansBold
ESPBUTTON.Text = "ESP"
ESPBUTTON.TextColor3 = Color3.fromRGB(255, 255, 127)
ESPBUTTON.TextScaled = true
ESPBUTTON.TextSize = 14.000
ESPBUTTON.TextWrapped = true

UICorner_9.Parent = ESPBUTTON

Close_2.Name = "Close"
Close_2.Parent = RenderFrame
Close_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Close_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Close_2.BorderSizePixel = 0
Close_2.Position = UDim2.new(0.891439795, 0, 0, 0)
Close_2.Size = UDim2.new(0.108374387, 0, 0.0692771077, 0)
Close_2.Font = Enum.Font.SourceSansBold
Close_2.Text = "X"
Close_2.TextColor3 = Color3.fromRGB(0, 0, 0)
Close_2.TextScaled = true
Close_2.TextSize = 14.000
Close_2.TextWrapped = true

WorldFrame.Name = "WorldFrame"
WorldFrame.Parent = ScreenGui
WorldFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
WorldFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
WorldFrame.BorderSizePixel = 0
WorldFrame.Position = UDim2.new(0.72428304, 0, 0.219999954, 0)
WorldFrame.Size = UDim2.new(0.147421926, 0, 0.405867964, 0)

TextWorld.Name = "Text World"
TextWorld.Parent = WorldFrame
TextWorld.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
TextWorld.BorderColor3 = Color3.fromRGB(255, 255, 255)
TextWorld.BorderSizePixel = 0
TextWorld.Size = UDim2.new(1, 0, 0.150602415, 0)
TextWorld.Font = Enum.Font.SourceSansBold
TextWorld.Text = "World"
TextWorld.TextColor3 = Color3.fromRGB(85, 255, 255)
TextWorld.TextScaled = true
TextWorld.TextSize = 14.000
TextWorld.TextStrokeColor3 = Color3.fromRGB(85, 255, 255)
TextWorld.TextWrapped = true

UICorner_10.Parent = TextWorld

UICorner_11.Parent = WorldFrame

infjump.Name = "inf jump"
infjump.Parent = WorldFrame
infjump.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
infjump.BorderColor3 = Color3.fromRGB(0, 0, 0)
infjump.BorderSizePixel = 0
infjump.Position = UDim2.new(0, 0, 0.150602415, 0)
infjump.Size = UDim2.new(0.862068951, 0, 0.150602415, 0)
infjump.Font = Enum.Font.SourceSansBold
infjump.Text = "INF JUMP"
infjump.TextColor3 = Color3.fromRGB(255, 255, 127)
infjump.TextScaled = true
infjump.TextSize = 14.000
infjump.TextWrapped = true

UICorner_12.Parent = infjump

Close_3.Name = "Close"
Close_3.Parent = WorldFrame
Close_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Close_3.BorderColor3 = Color3.fromRGB(0, 0, 0)
Close_3.BorderSizePixel = 0
Close_3.Position = UDim2.new(0.891439795, 0, 0, 0)
Close_3.Size = UDim2.new(0.108374387, 0, 0.0692771077, 0)
Close_3.Font = Enum.Font.SourceSansBold
Close_3.Text = "X"
Close_3.TextColor3 = Color3.fromRGB(0, 0, 0)
Close_3.TextScaled = true
Close_3.TextSize = 14.000
Close_3.TextWrapped = true

-- Scripts:

local function BBEBTD_fake_script() -- CombatFrame.DRAG SCRIPT 
	local script = Instance.new('LocalScript', CombatFrame)

	local parent: Frame = script.Parent
	parent.Draggable = true
	parent.Selectable = true
	parent.Active = true
end
coroutine.wrap(BBEBTD_fake_script)()
local function UCTR_fake_script() -- CombatFrame.RIGHTSHIFT TO OPEN 
	local script = Instance.new('LocalScript', CombatFrame)

	local Gui = script.Parent
	
	local function onKeyPress(input)
		if input.KeyCode == Enum.KeyCode.RightShift then
			if Gui.Visible == true then
				Gui.Visible = false
			else
				Gui.Visible = true
			end
		end
	end
	
	game:GetService("UserInputService").InputBegan:Connect(onKeyPress)
	
end
coroutine.wrap(UCTR_fake_script)()
local function QFOUMMA_fake_script() -- Close.LocalScript 
	local script = Instance.new('LocalScript', Close)

	local CombatFrame = script.Parent.Parent
	
	script.Parent.MouseButton1Click:Connect(function()
		CombatFrame.Visible = false
	end)
end
coroutine.wrap(QFOUMMA_fake_script)()
local function AZFGYK_fake_script() -- KillAura.LocalScript 
	local script = Instance.new('LocalScript', KillAura)

	script.Parent.MouseButton1Click:Connect(function()
		-- ✅ Start of your script
	
		-- ✅ Reference to the button
		local button = script.Parent  -- The button itself
		local KillAura = false  -- Track flying state
		local isOn = false  -- Toggle state for color change
	
		-- ✅ Functions to start and stop flying
		local function startFlying()
			print("✅ Flying Activated")
			KillAura = true
			-- Insert your flying logic here (e.g., changing position, adding BodyVelocity, etc.)
		end
	
		local function stopFlying()
			print("❌ Flying Deactivated")
			KillAura = false
			-- Insert logic to stop flying here (e.g., resetting gravity, removing BodyVelocity, etc.)
		end
	
		-- ✅ Toggle fly and button color when button is clicked
		button.MouseButton1Click:Connect(function()
			-- Toggle flying
			if KillAura then
				stopFlying()  -- Stop flying if already flying
			else
				startFlying()  -- Start flying if not already flying
			end
	
			-- Toggle button color (Green when flying, Red when not flying)
			isOn = not isOn  -- Flip the state
	
			if isOn then
				button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)  -- Green when ON
			else
				button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)  -- Red when OFF
			end
	
			button.Text = "KillAura"  -- Keep the text the same
		end)
	
		-- ✅ Rest of your combat and other logic goes here...
	
	end)
	-- ✅ Services
	local Players = game:GetService("Players")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer
	local Camera = workspace.CurrentCamera
	
	-- ✅ Remote Path
	local DefaultRemotePath = ReplicatedStorage:WaitForChild("rbxts_include")
		:WaitForChild("node_modules")
		:WaitForChild("@rbxts")
		:WaitForChild("net")
		:WaitForChild("out")
		:WaitForChild("_NetManaged")
	
	local SwordHitRemote = DefaultRemotePath:FindFirstChild("SwordHit")
	
	if not SwordHitRemote then
		warn("❌ SwordHit Remote NOT Found! Check the path.")
		return
	end
	print("✅ SwordHit Remote Found")
	
	-- ✅ Settings
	local KnockbackExploitEnabled = true      -- Toggle knockback exploit on/off
	local MaxKnockbackMultiplier = 3          -- Max knockback boost
	local KnockbackRange = 19                 -- Max range for knockback
	local MaxAuraRange = 30                   -- Max Kill Aura attack range
	
	-- ✅ Get Inventory and Sword
	local BedwarsTables = {
		ItemTable = debug.getupvalue(require(ReplicatedStorage.TS.item["item-meta"]).getItemMeta, 1)
	}
	
	local function GetInventory(Player)
		local Player = Player or LocalPlayer
		local Inventory = require(ReplicatedStorage.TS.inventory["inventory-util"]).InventoryUtil.getInventory(Player)
		return Inventory
	end
	
	local function GetBestSword()
		local HighestDamage, SwordData = -math.huge, nil
	
		for _, v in next, GetInventory(LocalPlayer).items do
			local SwordMetaGame = BedwarsTables.ItemTable[v.itemType] and BedwarsTables.ItemTable[v.itemType].sword
	
			if SwordMetaGame then
				local SwordDamage = (SwordMetaGame.damage / SwordMetaGame.attackSpeed)
	
				if SwordDamage > HighestDamage then
					HighestDamage = SwordDamage
					SwordData = v
				end
			end
		end
	
		if SwordData then
			print("✅ Best Sword:", SwordData.itemType)
			return SwordData.tool  -- ✅ Return the sword tool
		else
			warn("❌ No Sword Found")
			return nil
		end
	end
	
	-- ✅ Find Nearest Enemy
	local function getNearestEnemy(range)
		local nearest, nearestDist = nil, range
	
		for _, player in pairs(Players:GetPlayers()) do
			if player ~= LocalPlayer and player:IsA("Player") and player:GetAttribute("Team") ~= LocalPlayer:GetAttribute("Team") then
				local char = player.Character
				if char and char.PrimaryPart then
					local dist = (LocalPlayer.Character.PrimaryPart.Position - char.PrimaryPart.Position).Magnitude
					if dist < nearestDist then
						nearestDist = dist
						nearest = char
					end
				end
			end
		end
	
		return nearest, nearestDist
	end
	
	-- ✅ Dynamic Offset Calculation (For Perfect Hits)
	local function getDynamicOffset(distance)
		-- Offset scales dynamically with distance for precise hits
		local baseOffset = 14.4
		local offset = math.max((distance / 2) - 1, baseOffset)
		return offset
	end
	
	-- ✅ Knockback Multiplier Calculation
	local function getKnockbackMultiplier(distance)
		-- Closer enemies get stronger knockback
		if distance <= KnockbackRange then
			local scale = 1 + ((KnockbackRange - distance) / KnockbackRange) * (MaxKnockbackMultiplier - 1)
			return scale
		end
		return 1
	end
	
	-- ✅ Attack Function with Knockback & Dynamic Offset
	local function attackEntity(entity, sword)
		local character = LocalPlayer.Character
		if not character or not character.PrimaryPart then return end
	
		local rootPart = character.PrimaryPart
		local entityPrimaryPart = entity.PrimaryPart
	
		if rootPart and entityPrimaryPart then
			local distance = (rootPart.Position - entityPrimaryPart.Position).Magnitude
			local lookVector = CFrame.lookAt(rootPart.Position, entityPrimaryPart.Position).LookVector
	
			-- ✅ Dynamic offset calculation for perfect hits
			local offset = getDynamicOffset(distance)
			local selfPosition = ((math.max(distance - offset, 0) * lookVector) + rootPart.Position)
	
			-- ✅ Knockback Exploit Calculation
			local MouseRay = (entityPrimaryPart.Position - Camera.CFrame.Position).Unit
			local knockbackMultiplier = KnockbackExploitEnabled and getKnockbackMultiplier(distance) or 1
			local rayDirection = MouseRay * knockbackMultiplier
	
			-- ✅ Fire the remote with knockback and dynamic offset
			task.spawn(function()
				SwordHitRemote:FireServer({
					["weapon"] = sword,
					["chargedAttack"] = {["chargeRatio"] = 0},
					["entityInstance"] = entity,
	
					["validate"] = {
						["raycast"] = {
							["cameraPosition"] = {value = selfPosition},
							["rayDirection"] = {value = rayDirection}
						},
						["targetPosition"] = {value = entityPrimaryPart.Position},
						["selfPosition"] = {value = selfPosition}
					}
				})
	
				print("✅ Hit:", entity.Name, "➡️ Offset:", offset, "➡️ Knockback:", knockbackMultiplier, "➡️ Distance:", distance)
			end)
		end
	end
	
	-- ✅ Real-Time Kill Aura Execution
	local killAuraConnection = nil
	
	local function startKillAura()
		-- 🛑 Disconnect previous connection to prevent memory leaks
		if killAuraConnection then
			killAuraConnection:Disconnect()
		end
	
		-- ✅ Real-Time Execution with Heartbeat
		killAuraConnection = RunService.Heartbeat:Connect(function()
			-- 🛑 Validate character to avoid crashes on death
			if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
				warn("❌ Waiting for Respawn...")
				return
			end
	
			local sword = GetBestSword()
			local enemy, distance = getNearestEnemy(MaxAuraRange)
	
			if sword and enemy then
				attackEntity(enemy, sword)
			else
				warn("❌ No Enemy or Sword Found")
			end
		end)
	end
	
	-- ✅ Restart Kill Aura on Respawn
	LocalPlayer.CharacterAdded:Connect(function()
		task.wait(1) -- Wait for character to load
		print("✅ Respawn Detected - Restarting Kill Aura")
		startKillAura()
	end)
	
	-- ✅ Start Initial Kill Aura
	startKillAura()
end
coroutine.wrap(AZFGYK_fake_script)()
local function JJMNWR_fake_script() -- Speed.Speed Script 
	local script = Instance.new('LocalScript', Speed)

	-- LocalScript under the TextButton (UI Button)
	
	local player = game.Players.LocalPlayer
	local button = script.Parent
	
	-- Function to set WalkSpeed to 23
	local function setWalkSpeed()
		local character = player.Character
		if character then
			local humanoid = character:WaitForChild("Humanoid")
			humanoid.WalkSpeed = 23
		end
	end
	
	-- Set WalkSpeed when the button is clicked
	button.MouseButton1Click:Connect(function()
		setWalkSpeed()
	end)
	
	-- Set WalkSpeed to 23 when the player respawns
	player.CharacterAdded:Connect(function(character)
		-- Wait for the humanoid to load and set the WalkSpeed
		local humanoid = character:WaitForChild("Humanoid")
		humanoid.WalkSpeed = 23
	end)
	button.MouseButton1Click:Connect(function()
		if Speed then
			Speed()  -- Turn off flying
		else
			Speed()  -- Turn on flying
		end
	end)
	local button = script.Parent  -- The button itself
	local isOn = false  -- Toggle state
	
	local function toggle()
		isOn = not isOn  -- Flip state
	
		if isOn then
			button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)  -- Green
		else
			button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)  -- Red
		end
	
		button.Text = "SPEED"  -- Keep the text the same
	end
	
	button.MouseButton1Click:Connect(toggle)  -- Click event
	
end
coroutine.wrap(JJMNWR_fake_script)()
local function VZEJYON_fake_script() -- Fly.FlyScript 
	local script = Instance.new('LocalScript', Fly)

	-- LocalScript inside the TextButton (UI Button inside CombatFrame)
	
	local player = game.Players.LocalPlayer
	local button = script.Parent  -- Reference to the button
	local flying = false
	local speed = 23  -- Fly speed
	local bodyVelocity = nil
	
	local userInputService = game:GetService("UserInputService")
	
	-- Function to start flying
	local function startFlying()
		local character = player.Character
		if character and not flying then
			flying = true
	
			-- Create BodyVelocity to control horizontal and vertical movement (forward, backward, left, right, up, down)
			bodyVelocity = Instance.new("BodyVelocity")
			bodyVelocity.MaxForce = Vector3.new(500000, 500000, 500000)  -- Apply force in all directions
			bodyVelocity.Velocity = Vector3.new(0, 0, 0)  -- No initial velocity
			bodyVelocity.Parent = character:WaitForChild("HumanoidRootPart")
	
			-- Set PlatformStand to true to prevent rotation while flying
			local humanoid = character:WaitForChild("Humanoid")
			humanoid.PlatformStand = true
		end
	end
	
	-- Function to stop flying
	local function stopFlying()
		local character = player.Character
		if character and flying then
			flying = false
	
			-- Remove the BodyVelocity to stop flying
			if bodyVelocity then
				bodyVelocity:Destroy()
				bodyVelocity = nil
			end
	
			-- Reset PlatformStand to false to restore normal movement
			local humanoid = character:WaitForChild("Humanoid")
			humanoid.PlatformStand = false
		end
	end
	
	-- Flight controls (W = forward, S = backward, A = left, D = right, Space = up, Q = down)
	game:GetService("RunService").Heartbeat:Connect(function()
		if flying then
			local character = player.Character
			local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
	
			-- Keep the player's Y position fixed (no vertical movement initially)
			local yPosition = humanoidRootPart.Position.Y
	
			-- Get the direction the player is facing (LookVector for forward/backward, RightVector for left/right, UpVector for vertical)
			local forwardDirection = humanoidRootPart.CFrame.LookVector  -- Forward direction (Z-axis)
			local rightDirection = humanoidRootPart.CFrame.RightVector  -- Right direction (X-axis)
			local upDirection = humanoidRootPart.CFrame.UpVector  -- Up direction (Y-axis)
	
			-- Default velocity is zero
			local velocity = Vector3.new(0, 0, 0)
	
			-- Check key inputs for movement (W, S, A, D, Space, Q)
			if userInputService:IsKeyDown(Enum.KeyCode.W) then
				velocity = forwardDirection * speed  -- Move forward
			elseif userInputService:IsKeyDown(Enum.KeyCode.S) then
				velocity = -forwardDirection * speed  -- Move backward
			elseif userInputService:IsKeyDown(Enum.KeyCode.A) then
				velocity = -rightDirection * speed  -- Move left
			elseif userInputService:IsKeyDown(Enum.KeyCode.D) then
				velocity = rightDirection * speed  -- Move right
			elseif userInputService:IsKeyDown(Enum.KeyCode.Space) then
				velocity = upDirection * speed  -- Move up (jump)
			elseif userInputService:IsKeyDown(Enum.KeyCode.Q) then
				velocity = -upDirection * speed  -- Move down (descend)
			end
	
			-- Apply the horizontal and vertical velocity
			bodyVelocity.Velocity = Vector3.new(velocity.X, velocity.Y, velocity.Z)  -- Apply velocity in X, Y, Z axes
	
			-- Fix the Y position (keep player floating at the same height for horizontal movement)
			humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position.X, yPosition, humanoidRootPart.Position.Z)
		end
	end)
	
	-- Toggling fly with the button click inside CombatFrame
	button.MouseButton1Click:Connect(function()
		if flying then
			stopFlying()  -- Turn off flying
		else
			startFlying()  -- Turn on flying
		end
	end)
	local button = script.Parent  -- The button itself
	local isOn = false  -- Toggle state
	
	local function toggle()
		isOn = not isOn  -- Flip state
	
		if isOn then
			button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)  -- Green
		else
			button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)  -- Red
		end
	
		button.Text = "FLY"  -- Keep the text the same
	end
	
	button.MouseButton1Click:Connect(toggle)  -- Click event
	
end
coroutine.wrap(VZEJYON_fake_script)()
local function NOSET_fake_script() -- LINES.LINES SCRIPT 
	local script = Instance.new('LocalScript', LINES)

	local button = script.Parent
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer
	
	local espEnabled = false
	local connections = {}
	local activeParts = {}
	
	local function cleanUpLines()
		for _, part in activeParts do
			if part and part.Parent then
				part:Destroy()
			end
		end
		activeParts = {}
	end
	
	local function drawLines()
		local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
		local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
	
		while espEnabled do
			cleanUpLines()
	
			for _, player in Players:GetPlayers() do
				if player ~= LocalPlayer and player.Character then
					local targetChar = player.Character
					local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
	
					if targetRoot and targetRoot:IsDescendantOf(workspace) then
						local raycastParams = RaycastParams.new()
						raycastParams.FilterDescendantsInstances = {character, targetChar}
						raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	
						local result = workspace:Raycast(
							humanoidRootPart.Position,
							(targetRoot.Position - humanoidRootPart.Position),
							raycastParams
						)
	
						if result then
							local part = Instance.new("Part")
							part.Material = Enum.Material.Neon
							part.Color = Color3.new(1, 1, 1)
							part.Size = Vector3.new(0.2, 0.2, (humanoidRootPart.Position - targetRoot.Position).Magnitude)
							part.Anchored = true
							part.CanCollide = false
							part.Transparency = 0.5
							part.CFrame = CFrame.new(humanoidRootPart.Position, targetRoot.Position) * CFrame.new(0, 0, -part.Size.Z/2)
							part.Parent = workspace
							table.insert(activeParts, part)
						end
					end
				end
			end
			task.wait(0.1)
		end
	end
	
	button.MouseButton1Click:Connect(function()
		espEnabled = not espEnabled
	
		if espEnabled then
			drawLines()
		else
			cleanUpLines()
		end
	end)
	
	LocalPlayer.CharacterAdded:Connect(function()
		if espEnabled then
			cleanUpLines()
		end
	end)
	local button = script.Parent  -- The button itself
	local isOn = false  -- Toggle state
	
	local function toggle()
		isOn = not isOn  -- Flip state
	
		if isOn then
			button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)  -- Green
		else
			button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)  -- Red
		end
		button.Text = "Lines"  -- Keep the text the same
	end
	
	button.MouseButton1Click:Connect(toggle)  -- Click event
	
end
coroutine.wrap(NOSET_fake_script)()
local function ERLXRT_fake_script() -- ESPBUTTON.ESP SCRIPT 
	local script = Instance.new('LocalScript', ESPBUTTON)

	local players = game:GetService("Players")
	local localPlayer = players.LocalPlayer
	local runService = game:GetService("RunService")
	
	script.Parent.MouseButton1Up:Connect(function()
		local function createESP(player)
			-- Create highlight
			local highlight = Instance.new("Highlight")
			highlight.Name = player.Name .. "_ESP"
			highlight.Adornee = player.Character
			highlight.FillTransparency = 1
			highlight.OutlineColor = Color3.new(1, 1, 1) -- White color
			highlight.OutlineTransparency = 0
			highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
			highlight.Parent = player.Character
	
			-- Create name tag
			local billboardGui = Instance.new("BillboardGui")
			billboardGui.Name = player.Name .. "_NameTag"
			billboardGui.Adornee = player.Character:FindFirstChild("HumanoidRootPart")
			billboardGui.Size = UDim2.new(0, 100, 0, 50)
			billboardGui.StudsOffset = Vector3.new(0, 2, 0)
			billboardGui.AlwaysOnTop = true
			billboardGui.Parent = player.Character
	
			local textLabel = Instance.new("TextLabel")
			textLabel.Size = UDim2.new(1, 0, 1, 0)
			textLabel.BackgroundTransparency = 1
			textLabel.Text = player.Name
			textLabel.TextColor3 = Color3.new(1, 1, 1) -- White color
			textLabel.TextStrokeTransparency = 0
			textLabel.Parent = billboardGui
		end
	
		local function addESP()
			for _, player in pairs(players:GetPlayers()) do
				if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					if not player.Character:FindFirstChild(player.Name .. "_ESP") then
						createESP(player)
					end
				end
			end
		end
	
		runService.RenderStepped:Connect(function()
			addESP()
		end)
	
		players.PlayerRemoving:Connect(function(player)
			if player.Character and player.Character:FindFirstChild(player.Name .. "_ESP") then
				player.Character[player.Name .. "_ESP"]:Destroy()
				player.Character[player.Name .. "_NameTag"]:Destroy()
			end
		end)
	end)
	local button = script.Parent  -- The button itself
	local isOn = false  -- Toggle state
	
	local function toggle()
		isOn = not isOn  -- Flip state
	
		if isOn then
			button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)  -- Green
		else
			button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)  -- Red
		end
	
		button.Text = "ESP"  -- Keep the text the same
	end
	
	button.MouseButton1Click:Connect(toggle)  -- Click event
	
end
coroutine.wrap(ERLXRT_fake_script)()
local function LRVE_fake_script() -- RenderFrame.DRAG SCRIPT 
	local script = Instance.new('LocalScript', RenderFrame)

	local parent: Frame = script.Parent
	parent.Draggable = true
	parent.Selectable = true
	parent.Active = true
end
coroutine.wrap(LRVE_fake_script)()
local function SCARBS_fake_script() -- RenderFrame.RIGHTSHIFT TO OPEN 
	local script = Instance.new('LocalScript', RenderFrame)

	local Gui = script.Parent
	
	local function onKeyPress(input)
		if input.KeyCode == Enum.KeyCode.RightShift then
			if Gui.Visible == true then
				Gui.Visible = false
			else
				Gui.Visible = true
			end
		end
	end
	
	game:GetService("UserInputService").InputBegan:Connect(onKeyPress)
	
end
coroutine.wrap(SCARBS_fake_script)()
local function MGKOZ_fake_script() -- Close_2.CLOSE SCRIPT 
	local script = Instance.new('LocalScript', Close_2)

	local RenderFrame = script.Parent.Parent
	
	script.Parent.MouseButton1Click:Connect(function()
		RenderFrame.Visible = false
	end)
end
coroutine.wrap(MGKOZ_fake_script)()
local function YKMSDD_fake_script() -- infjump.INF JUMP SCRIPT 
	local script = Instance.new('LocalScript', infjump)

	local button = script.Parent
	local player = game.Players.LocalPlayer
	local UIS = game:GetService("UserInputService")
	local infJumpEnabled = false  -- Default off
	
	-- Toggle infinite jump when button is clicked
	button.MouseButton1Click:Connect(function()
		infJumpEnabled = not infJumpEnabled
		button.Text =  "Infinite Jump: "..infJumpEnabled
	end)
	
	UIS.JumpRequest:Connect(function()
		if infJumpEnabled and player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
			player.Character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end)
	local button = script.Parent  -- The button itself
	local isOn = false  -- Toggle state
	
	local function toggle()
		isOn = not isOn  -- Flip state
	
		if isOn then
			button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)  -- Green
		else
			button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)  -- Red
		end
	
		button.Text = "InfJump"  -- Keep the text the same
	end
	
	button.MouseButton1Click:Connect(toggle)  -- Click event
	
end
coroutine.wrap(YKMSDD_fake_script)()
local function PSTG_fake_script() -- WorldFrame.DRAG SCRIPT 
	local script = Instance.new('LocalScript', WorldFrame)

	local parent: Frame = script.Parent
	parent.Draggable = true
	parent.Selectable = true
	parent.Active = true
end
coroutine.wrap(PSTG_fake_script)()
local function BTHTXHF_fake_script() -- WorldFrame.RIGHTSHIFT TO OPEN 
	local script = Instance.new('LocalScript', WorldFrame)

	local Gui = script.Parent
	
	local function onKeyPress(input)
		if input.KeyCode == Enum.KeyCode.RightShift then
			if Gui.Visible == true then
				Gui.Visible = false
			else
				Gui.Visible = true
			end
		end
	end
	
	game:GetService("UserInputService").InputBegan:Connect(onKeyPress)
	
end
coroutine.wrap(BTHTXHF_fake_script)()
local function BDJM_fake_script() -- Close_3.CLOSE SCRIPT 
	local script = Instance.new('LocalScript', Close_3)

	local WorldFrame = script.Parent.Parent
	
	script.Parent.MouseButton1Click:Connect(function()
		WorldFrame.Visible = false
	end)
end
